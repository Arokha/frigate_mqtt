{
  "version": 3,
  "sources": ["src/main.ts", "src/camera.ts", "src/config.ts", "src/frigate.ts"],
  "sourcesContent": ["import { connect, MqttClient } from \"mqtt\";\nimport { FrigateCamera, CameraState } from \"./camera\";\nimport { readFileSync } from \"fs\";\nimport { parse as yamlParse } from \"yaml\";\nimport { configSchema } from \"./config\";\nimport { frigateStateSchema, FrigateState } from \"./frigate\";\n\n// Read config from config.yaml file\nconst configFile = readFileSync(\"config.yml\", \"utf8\");\nconst config = configSchema.parse(yamlParse(configFile));\n\n// Create an array of FrigateCamera instances based on the config\nconst cameras = config.cameras.map((cameraConfig) => {\n    const camera = new FrigateCamera(cameraConfig.name);\n    return camera;\n});\n\n// Connect to the MQTT broker\nlet connected_to_broker = false;\nlet broker: MqttClient;\n\n/**\n * Sends a message to a topic and waits for a response on another topic\n * @param publishTopic Topic to publish to\n * @param subscribeTopic Topic to listen for response on\n * @param message Message to publish\n * @param timeout Timeout in milliseconds\n * @returns Promise that resolves with the response message or rejects on timeout\n */\nfunction sendAndWaitForResponse(\n    publishTopic: string, \n    subscribeTopic: string, \n    message: string, \n    timeout: number = 5000\n): Promise<Buffer> {\n    return new Promise((resolve, reject) => {\n        // Set up a one-time listener for the response\n        const responseHandler = (topic: string, responseMessage: Buffer) => {\n            if (topic === subscribeTopic) {\n                broker.removeListener('message', responseHandler);\n                clearTimeout(timeoutId);\n                resolve(responseMessage);\n            }\n        };\n        \n        broker.on('message', responseHandler);\n        \n        // Set up a timeout\n        const timeoutId = setTimeout(() => {\n            broker.removeListener('message', responseHandler);\n            reject(new Error(`Timeout waiting for response on ${subscribeTopic}`));\n        }, timeout);\n        \n        // Publish the message\n        broker.publish(publishTopic, message, { qos: 1 }, (err) => {\n            if (err) {\n                broker.removeListener('message', responseHandler);\n                clearTimeout(timeoutId);\n                reject(err);\n            }\n        });\n    });\n}\n\n/**\n * Connect to the MQTT broker and set up event handlers\n */\nfunction connectToBroker(): void {\n    // Close any existing connections\n    if (broker) {\n        try {\n            broker.end(true);\n        } catch (e) {\n            // Ignore errors from ending the broker\n        }\n    }\n    \n    // Connect to the MQTT broker\n    broker = connect(config.mqtt_url, {port: config.mqtt_port});\n    \n    // Set up event handlers\n    broker.on(\"connect\", handleConnect);\n    broker.on(\"error\", handleError);\n    broker.on(\"close\", handleClose);\n    broker.on(\"message\", handleMessage);\n}\n\n/**\n * Handle broker connect event\n */\nfunction handleConnect(): void {\n    console.log(\"[MAIN] Connected to MQTT broker\");\n    connected_to_broker = true;\n    \n    // Subscribe to required topics\n    setupSubscriptions();\n    \n    // Initial poke to get camera states\n    pokeFrigate().catch(err => {\n        console.error(\"[MAIN] Error during initial poke:\", err);\n    });\n}\n\n/**\n * Handle broker error event\n */\nfunction handleError(err: Error): void {\n    console.error(\"[MAIN] Error connecting to MQTT broker:\", err);\n    connected_to_broker = false;\n}\n\n/**\n * Handle broker close event\n */\nfunction handleClose(): void {\n    console.log(\"[MAIN] Connection to MQTT broker closed\");\n    connected_to_broker = false;\n}\n\n/**\n * Set up subscriptions to required topics\n */\nfunction setupSubscriptions(): void {\n    // Subscribe to camera_activity topic\n    broker.subscribe(`${config.mqtt_root}/camera_activity`, { qos: 1 }, (err) => {\n        if (err) {\n            console.error(`[MAIN] Error subscribing to ${config.mqtt_root}/camera_activity:`, err);\n        } else {\n            console.log(`[MAIN] Subscribed to ${config.mqtt_root}/camera_activity`);\n        }\n    });\n\n    // Subscribe to individual camera topics\n    const cameraTopics = cameras.map((camera) => {\n        return [\n            camera.getDetectUpdateTopic(config.mqtt_root),\n            camera.getMotionUpdateTopic(config.mqtt_root),\n        ];\n    }).flat();\n    broker.subscribe(cameraTopics, { qos: 1 }, (err) => {\n        if (err) {\n            console.error(`[MAIN] Error subscribing to camera topics:`, err);\n        } else {\n            console.log(`[MAIN] Subscribed to camera topics`);\n        }\n    });\n}\n\n// Initialize the connection\nconnectToBroker();\n\n// Wait for connection to be established\n(async function waitForConnection() {\n    while(!connected_to_broker) {\n        console.log(\"[MAIN] Waiting for connection to MQTT broker...\");\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n})();\n\n// Global variables for the health check\nlet healthCheckInterval: NodeJS.Timeout;\nconst HEALTH_CHECK_INTERVAL = 60000; // 60 seconds\n\n/**\n * Set up the periodic health check that pokes the broker\n */\nfunction setupHealthCheck(): void {\n    // Clear any existing interval\n    if (healthCheckInterval) {\n        clearInterval(healthCheckInterval);\n    }\n    \n    // Set up a new interval\n    healthCheckInterval = setInterval(() => {\n        pokeFrigate().catch(err => {\n            console.error(\"[MAIN] Error during scheduled poke:\", err);\n        });\n    }, HEALTH_CHECK_INTERVAL);\n    \n    //console.log(`Set up health check to poke broker every ${HEALTH_CHECK_INTERVAL / 1000} seconds`);\n}\n\n/**\n * Force a camera state update and get the latest detected objects\n * @param camera The camera to get state for\n * @param resetInterval Whether to reset the health check interval (default: true)\n * @returns Promise that resolves when the state has been updated\n */\nasync function refreshCameraState(camera: FrigateCamera, resetInterval: boolean = true): Promise<void> {\n    console.log(`[CAM:${camera.getName()}] Refreshing state...`);\n    \n    try {\n        // Poke the broker to get latest camera states\n        await pokeFrigate();\n        \n        // Reset the health check interval to avoid duplicate pokes\n        if (resetInterval) {\n            setupHealthCheck();\n        }\n        \n        console.log(`[CAM:${camera.getName()}] Current objects: ${camera.detected_objects.length > 0 ? camera.detected_objects.join(', ') : 'none'}`);\n    } catch (error) {\n        console.error(`[CAM:${camera.getName()}] Error refreshing state:`, error);\n        throw error;\n    }\n}\n\n/**\n * Handle incoming messages from the broker\n */\nfunction handleMessage(topic: string, message: Buffer): void {\n    if(!topic.startsWith(config.mqtt_root+\"/\")) {\n        // Ignore messages that don't start with the root topic\n        return;\n    }\n\n    // Trim the root from the topic string\n    const trimmedTopic = topic.substring(config.mqtt_root.length + 1);\n\n    // JSON object like this with every camera as a key in the top object:\n    // {\"camera_name\": {\"motion\": false, \"objects\": [], \"config\": {\"detect\": true, \"snapshots\": false, \"record\": true, \"audio\": false, \"autotracking\": false}}}\n    // Note the \"motion\" and \"objects\" are what is CURRENTLY SENSED by the camera, not the config, unlike the \"config\" object\n    if(trimmedTopic === \"camera_activity\") {\n        console.log(\"[MAIN] Received camera_activity message:\", message.toString());\n        try {\n            const rawStates = JSON.parse(message.toString());\n            // If Frigate returns only a {} then it is not done coming up yet\n            if (Object.keys(rawStates).length === 0) {\n                console.log(\"[MAIN] Received empty camera_activity message, ignoring...\");\n                return;\n            }\n            // Validate the structure of the received data\n            const parsedStates = frigateStateSchema.parse(rawStates);\n            for (const cameraName in parsedStates) {\n                const cameraState = parsedStates[cameraName];\n                const camera = cameras.find((cam) => cam.getName() === cameraName);\n                if (camera) {\n                    // Update the camera state with both detect config and detected objects\n                    camera.setCameraState({\n                        detect_enabled: cameraState.config.detect,\n                        detected_objects: cameraState.objects\n                    });\n                    console.log(`[CAM:${cameraName}] Updated state, detected objects: ${cameraState.objects.length > 0 ? cameraState.objects.join(', ') : 'none'}`);\n                }\n            }\n        } catch (error) {\n            console.error(\"[MAIN] Error parsing camera_activity message:\", error);\n        }\n        return;\n    }\n    // Split the topic on / to see if it has a camera name with the first part (or only part)\n    const topicParts = trimmedTopic.split(\"/\");\n    const cameraName = topicParts[0];\n    const camera = cameras.find((cam) => cam.getName() === cameraName);\n    if (!camera) {\n        // Don't log anything, there are MANY other topics that are not camera topics\n        return;\n    }\n\n    // Could be a camera status update. Of those, the ones we care about are 'motion' and 'detect'\n    // If it is an update from one of those, there will be a 3rd part as well, 'state'. Those are the only ones we care about.\n    if (topicParts.length === 3 && topicParts[1] === \"state\") {\n        const category = topicParts[2];\n        const state = message.toString();\n        switch (category) {\n            case \"motion\":\n                // Update the camera state\n                camera.setCameraState({motion_enabled: state === \"ON\"});\n                console.log(`[CAM:${cameraName}] Updated motion state: ${state}`);\n                break;\n            case \"detect\":\n                // Update the camera state\n                camera.setCameraState({detect_enabled: state === \"ON\"});\n                console.log(`[CAM:${cameraName}] Updated detect state: ${state}`);\n                break;\n        }\n    }\n}\n\n/**\n * If Frigate is running, it will publish to the frigate/camera_activity topic on receiving a message on frigate/onConnect\n * This function will wait for a response on the camera_activity topic and reject if none is received within the timeout\n */\nasync function pokeFrigate(): Promise<void> {\n    try {\n        await sendAndWaitForResponse(\n            `${config.mqtt_root}/onConnect`,\n            `${config.mqtt_root}/camera_activity`,\n            \"poke\",\n            5000\n        );\n        console.log(\"[MAIN] Successfully received response from Frigate\");\n    } catch (error) {\n        console.error(\"[MAIN] Error communicating with Frigate:\", error);\n        \n        // If we've lost connection, try to reconnect\n        console.log(\"[MAIN] Connection appears to be dead. Attempting to reconnect...\");\n        connected_to_broker = false;\n        broker.end(true);\n        \n        // Attempt to reconnect\n        connectToBroker();\n        throw error; // Re-throw to allow caller to handle\n    }\n}\n\n/**\n * Set the camera's detect state and wait for confirmation\n * @param camera The camera to set the detect state for\n * @param state The state to set (true for ON, false for OFF)\n * @returns Promise that resolves with true if successful, false otherwise\n */\nasync function setCameraDetect(camera: FrigateCamera, state: boolean): Promise<boolean> {\n    const publishTopic = camera.getDetectSetTopic(config.mqtt_root);\n    const subscribeTopic = camera.getDetectUpdateTopic(config.mqtt_root);\n    const message = state ? \"ON\" : \"OFF\";\n    \n    try {\n        const response = await sendAndWaitForResponse(publishTopic, subscribeTopic, message, 5000);\n        const responseStr = response.toString();\n        console.log(`[CAM:${camera.getName()}] Received response for detect: ${responseStr}`);\n        \n        // Verify the response matches what we expect\n        if (responseStr === message) {\n            camera.setCameraState({ detect_enabled: state });\n            return true;\n        } else {\n            console.error(`[CAM:${camera.getName()}] Unexpected response for detect: expected ${message}, got ${responseStr}`);\n            return false;\n        }\n    } catch (error) {\n        console.error(`[CAM:${camera.getName()}] Error setting detect state:`, error);\n        \n        // If we've lost connection, try to reconnect\n        console.log(\"[MAIN] Connection appears to be dead. Attempting to reconnect...\");\n        connected_to_broker = false;\n        broker.end(true);\n        \n        // Attempt to reconnect\n        connectToBroker();\n        return false;\n    }\n}\n\n/**\n * Set the camera's motion state and wait for confirmation\n * @param camera The camera to set the motion state for\n * @param state The state to set (true for ON, false for OFF)\n * @returns Promise that resolves with true if successful, false otherwise\n */\nasync function setCameraMotion(camera: FrigateCamera, state: boolean): Promise<boolean> {\n    const publishTopic = camera.getMotionSetTopic(config.mqtt_root);\n    const subscribeTopic = camera.getMotionUpdateTopic(config.mqtt_root);\n    const message = state ? \"ON\" : \"OFF\";\n    \n    try {\n        const response = await sendAndWaitForResponse(publishTopic, subscribeTopic, message, 5000);\n        const responseStr = response.toString();\n        console.log(`[CAM:${camera.getName()}] Received response for motion: ${responseStr}`);\n        \n        // Verify the response matches what we expect\n        if (responseStr === message) {\n            camera.setCameraState({ motion_enabled: state });\n            return true;\n        } else {\n            console.error(`[CAM:${camera.getName()}] Unexpected response for motion: expected ${message}, got ${responseStr}`);\n            return false;\n        }\n    } catch (error) {\n        console.error(`[CAM:${camera.getName()}] Error setting motion state:`, error);\n        \n        // If we've lost connection, try to reconnect\n        console.log(\"[MAIN] Connection appears to be dead. Attempting to reconnect...\");\n        connected_to_broker = false;\n        broker.end(true);\n        \n        // Attempt to reconnect\n        connectToBroker();\n        return false;\n    }\n}\n\n/**\n * Sends a PTZ preset command to a camera\n * @param camera The camera to send the PTZ command to\n * @param presetName The name of the preset to move to\n * @returns Promise that resolves when the command is sent\n */\nasync function setCameraPtzPreset(camera: FrigateCamera, presetName: string): Promise<boolean> {\n    const ptzTopic = camera.getPtzTopic(config.mqtt_root);\n    const message = `preset_${presetName}`;\n    \n    try {\n        // Publish the message and return a promise that resolves when published\n        await new Promise<void>((resolve, reject) => {\n            broker.publish(ptzTopic, message, { qos: 1 }, (err) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n        \n        console.log(`[CAM:${camera.getName()}] Sent PTZ preset command: ${message}`);\n        camera.setCameraState({ task: 'homing' }); // Update the camera state\n        return true;\n    } catch (error) {\n        console.error(`[CAM:${camera.getName()}] Error sending PTZ preset command:`, error);\n        \n        // Check if this is a connection issue\n        if (!connected_to_broker) {\n            // If we've lost connection, try to reconnect\n            console.log(\"[MAIN] Connection appears to be dead. Attempting to reconnect...\");\n            broker.end(true);\n            connectToBroker();\n        }\n        return false;\n    }\n}\n\n/**\n * Safely move a camera to a preset position by:\n * 1. Disabling object detection\n * 2. Disabling motion detection\n * 3. Moving to the preset\n * 4. Re-enabling motion detection\n * 5. Re-enabling object detection\n * \n * @param camera The camera to move\n * @param presetName The preset position name to move to\n * @param restoreDetection Whether to restore detection settings after movement (default: true)\n * @param slewTime Milliseconds to wait after moving before restoring detection (default: 5000)\n * @returns Promise that resolves with true if all operations succeeded\n */\nasync function safeMoveCameraToPreset(\n    camera: FrigateCamera, \n    presetName: string, \n    restoreDetection: boolean = true,\n    slewTime: number = 7 * 1000 // How long we expect the camera to take, at most, to slew to a preset\n): Promise<boolean> {\n    console.log(`[CAM:${camera.getName()}] Safely moving to preset ${presetName}...`);\n    \n    // Store original detection states to restore later if needed\n    const originalDetectState = camera.detect_enabled;\n    const originalMotionState = camera.motion_enabled;\n    \n    // Step 1: Disable object detection\n    if (originalDetectState) {\n        console.log(`[CAM:${camera.getName()}] Disabling object detection...`);\n        const detectResult = await setCameraDetect(camera, false);\n        if (!detectResult) {\n            console.error(`[CAM:${camera.getName()}] Failed to disable object detection`);\n            return false;\n        }\n    }\n    \n    // Step 2: Disable motion detection\n    if (originalMotionState) {\n        console.log(`[CAM:${camera.getName()}] Disabling motion detection...`);\n        const motionResult = await setCameraMotion(camera, false);\n        if (!motionResult) {\n            console.error(`[CAM:${camera.getName()}] Failed to disable motion detection`);\n            // Try to restore original detection state\n            if (originalDetectState) {\n                await setCameraDetect(camera, true);\n            }\n            return false;\n        }\n    }\n    \n    // Step 3: Move to preset\n    console.log(`[CAM:${camera.getName()}] Moving to preset ${presetName}...`);\n    const ptzResult = await setCameraPtzPreset(camera, presetName);\n    if (!ptzResult) {\n        console.error(`[CAM:${camera.getName()}] Failed to move to preset ${presetName}`);\n        // Try to restore original states\n        if (restoreDetection) {\n            if (originalMotionState) {\n                await setCameraMotion(camera, true);\n            }\n            if (originalDetectState) {\n                await setCameraDetect(camera, true);\n            }\n        }\n        return false;\n    }\n    \n    // Only restore detection if requested\n    if (restoreDetection) {\n        // Wait for camera to finish moving before re-enabling detection\n        console.log(`[CAM:${camera.getName()}] Waiting ${slewTime}ms for camera movement to complete...`);\n        await new Promise(resolve => setTimeout(resolve, slewTime));\n        \n        // Step 4: Re-enable motion detection\n        if (originalMotionState) {\n            console.log(`[CAM:${camera.getName()}] Re-enabling motion detection...`);\n            await setCameraMotion(camera, true);\n        }\n        \n        // Step 5: Re-enable object detection\n        if (originalDetectState) {\n            console.log(`[CAM:${camera.getName()}] Re-enabling object detection...`);\n            await setCameraDetect(camera, true);\n        }\n    }\n    \n    console.log(`[CAM:${camera.getName()}] Finished move commands for preset ${presetName}`);\n    return true;\n}\n\n/**\n * Move a camera through a sequence of preset positions\n * @param camera The camera to move\n * @param presetNames Array of preset names to move through\n * @param dwellTime Milliseconds to wait at each position (default: 10000 - 10 seconds)\n * @param maxRetries Number of times to check for objects before moving on (default: 3)\n * @returns Promise that resolves when patrol is complete\n */\nasync function patrolCameraPresets(\n    camera: FrigateCamera,\n    presetNames: string[],\n    dwellTime: number = 30 * 1000, // Time to wait at each preset\n    maxRetries: number = 10\n): Promise<boolean> {\n    console.log(`[CAM:${camera.getName()}] Starting patrol through ${presetNames.length} positions`);\n    camera.setCameraState({ task: 'patrolling' });\n    \n    // First preset - disable detection but don't restore yet\n    if (presetNames.length > 0) {\n        // Get the latest camera state before starting patrol\n        try {\n            await refreshCameraState(camera);\n            \n            // Check if there are objects detected\n            if (camera.detected_objects.length > 0) {\n                console.log(`[CAM:${camera.getName()}] Skipping patrol because objects are detected: ${camera.detected_objects.join(', ')}`);\n                camera.setCameraState({ task: 'normal' });\n                return false;\n            }\n        } catch (error) {\n            console.error(`[CAM:${camera.getName()}] Error refreshing camera state before patrol:`, error);\n            // Continue anyway\n        }\n        \n        const result = await safeMoveCameraToPreset(camera, presetNames[0], false);\n        if (!result) {\n            console.error(`[CAM:${camera.getName()}] Failed to start patrol`);\n            camera.setCameraState({ task: 'normal' });\n            return false;\n        }\n        \n        // Wait at first position\n        await new Promise(resolve => setTimeout(resolve, dwellTime));\n    }\n    \n    // Remaining presets\n    for (let i = 1; i < presetNames.length; i++) {\n        // Before moving to the next position, check explicitly for objects\n        let retryCount = 0;\n        let shouldWait = true;\n        \n        while (shouldWait && retryCount < maxRetries) {\n            // Get latest state before deciding to move\n            try {\n                await refreshCameraState(camera);\n                \n                if (camera.detected_objects.length === 0) {\n                    // No objects detected, ok to move\n                    shouldWait = false;\n                } else {\n                    console.log(`[CAM:${camera.getName()}] Objects detected at position ${i}: ${camera.detected_objects.join(', ')}. Waiting...`);\n                    \n                    // Wait another dwell time and check again\n                    await new Promise(resolve => setTimeout(resolve, dwellTime));\n                    retryCount++;\n                }\n            } catch (error) {\n                console.error(`[CAM:${camera.getName()}] Error refreshing camera state during patrol:`, error);\n                // If we can't get the state, we'll assume it's safe to continue\n                shouldWait = false;\n            }\n        }\n        \n        if (shouldWait) {\n            console.log(`[CAM:${camera.getName()}] Still detecting objects after ${maxRetries} retries, continuing patrol anyway`);\n        }\n        \n        const result = await safeMoveCameraToPreset(camera, presetNames[i], i === presetNames.length - 1);\n        if (!result) {\n            console.error(`[CAM:${camera.getName()}] Failed to continue patrol at position ${i+1}`);\n            // Try to restore detection\n            const originalDetectState = camera.detect_enabled;\n            const originalMotionState = camera.motion_enabled;\n            if (originalMotionState) {\n                await setCameraMotion(camera, true);\n            }\n            if (originalDetectState) {\n                await setCameraDetect(camera, true);\n            }\n            camera.setCameraState({ task: 'normal' });\n            return false;\n        }\n        \n        // Only wait at intermediate positions\n        if (i < presetNames.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, dwellTime));\n        }\n    }\n    \n    camera.setCameraState({ task: 'normal' });\n    console.log(`[CAM:${camera.getName()}] Completed patrol`);\n    return true;\n}\n\n/**\n * Set up rehoming and patrol schedules for all cameras based on their configuration\n */\nfunction setupCameraSchedules(): void {\n    console.log(\"[MAIN] Setting up camera schedules...\");\n    \n    // Set up schedules for each camera\n    cameras.forEach((camera) => {\n        const cameraConfig = config.cameras.find(c => c.name === camera.getName());\n        if (!cameraConfig) {\n            console.error(`[MAIN] Could not find configuration for camera ${camera.getName()}`);\n            return;\n        }\n        \n        // Set up rehoming schedule if enabled\n        if (cameraConfig.rehome && cameraConfig.rehome_after > 0) {\n            console.log(`[MAIN] Setting up rehoming schedule for ${camera.getName()} every ${cameraConfig.rehome_after} seconds`);\n            setInterval(async () => {\n                // Only rehome if the camera is not currently patrolling\n                if (camera.task !== 'patrolling') {\n                    try {\n                        // Get the latest camera state before deciding to rehome\n                        await refreshCameraState(camera);\n                        \n                        // Check if there are objects detected\n                        if (camera.detected_objects.length === 0) {\n                            console.log(`[CAM:${camera.getName()}] Rehoming...`);\n                            await safeMoveCameraToPreset(camera, \"1\").catch(err => {\n                                console.error(`[CAM:${camera.getName()}] Error rehoming:`, err);\n                            });\n                        } else {\n                            console.log(`[CAM:${camera.getName()}] Skipping rehome because objects are detected: ${camera.detected_objects.join(', ')}`);\n                        }\n                    } catch (err) {\n                        console.error(`[CAM:${camera.getName()}] Error checking state before rehoming:`, err);\n                    }\n                } else {\n                    console.log(`[CAM:${camera.getName()}] Skipping rehome because task is currently: ${camera.task}`);\n                }\n            }, cameraConfig.rehome_after * 1000);\n        }\n        \n        // Set up patrol schedule if enabled\n        if (cameraConfig.patrols && cameraConfig.patrol_every > 0 && cameraConfig.patrol_route.length > 0) {\n            console.log(`[CAM:${camera.getName()}] Setting up patrol schedule: every ${cameraConfig.patrol_every} seconds`);\n            setInterval(async () => {\n                try {\n                    // Get the latest camera state before deciding to patrol\n                    await refreshCameraState(camera);\n                    \n                    // Check if there are objects detected\n                    if (camera.detected_objects.length === 0) {\n                        console.log(`[CAM:${camera.getName()}] Starting patrol...`);\n                        await patrolCameraPresets(camera, cameraConfig.patrol_route).catch(err => {\n                            console.error(`[CAM:${camera.getName()}] Error patrolling:`, err);\n                        });\n                    } else {\n                        console.log(`[CAM:${camera.getName()}] Skipping patrol because objects are detected: ${camera.detected_objects.join(', ')}`);\n                    }\n                } catch (err) {\n                    console.error(`[CAM:${camera.getName()}] Error checking state before patrolling:`, err);\n                }\n            }, cameraConfig.patrol_every * 1000);\n        }\n    });\n}\n\n\n// Initialize camera schedules and health check after connection is established\n(async function initialize() {\n    // Wait for connection to be established\n    while(!connected_to_broker) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    // Set up camera schedules\n    setupCameraSchedules();\n    \n    // Set up health check\n    setupHealthCheck();\n})();\n", "export interface CameraState {\n    motion_enabled?: boolean;\n    detect_enabled?: boolean;\n    task?: 'normal' | 'homing' | 'patrolling';\n    detected_objects?: string[]; // Add this field\n}\n\nexport class FrigateCamera {\n    name: string;\n    motion_enabled: boolean = false;\n    detect_enabled: boolean = false;\n    task: 'normal' | 'homing' | 'patrolling' = 'normal';\n    detected_objects: string[] = [];\n\n    constructor(name: string, mqtt_url: string = 'localhost', mqtt_port: number = 1883) {\n        this.name = name;\n    }\n\n    getName(): string {\n        return this.name;\n    }\n\n    /**\n     * The topic where the camera will publish changes to the object detection state.\n     * @param root Root topic name for MQTT\n     * @returns The MQTT topic where 'ON' or 'OFF' will be published\n     */\n    getDetectUpdateTopic(root = \"frigate\"): string {\n        return `${root}/${this.name}/detect`;\n    }\n    /**\n     * Note: Must be disabled before disabling motion detection.\n     * @param root Root topic name for MQTT\n     * @returns The MQTT topic used for enabling/disabling object detection\n     */\n    getDetectSetTopic(root = \"frigate\"): string {\n        return `${root}/${this.name}/detect/set`;\n    }\n    /**\n     * The topic where the camera will publish changes to the motion detection state.\n     * @param root Root topic name for MQTT\n     * @returns The MQTT topic where 'ON' or 'OFF' will be published\n     */\n    getMotionUpdateTopic(root = \"frigate\"): string {\n        return `${root}/${this.name}/motion`;\n    }\n    /**\n     * Note: Detection MUST be disabled to also disable motion detection.\n     * @param root Root topic name for MQTT\n     * @returns The MQTT topic used for enabling/disabling motion detection\n     */\n    getMotionSetTopic(root = \"frigate\"): string {\n        return `${root}/${this.name}/motion/set`;\n    }\n\n    /**\n     * The topic that Frigate listens for instructions on what to do with a PTZ-enabled camera.\n     * @param root Root topic name for MQTT\n     * @returns The MQTT topic where PTZ commands can be sent\n     */\n    getPtzTopic(root = \"frigate\"): string {\n        return `${root}/${this.name}/ptz`;\n    }\n\n    /**\n     * Update the state of the camera given an MQTT client to ask\n     * @param newstate The new state to set\n     * @returns true if the state was updated, false otherwise\n     */\n    setCameraState(newstate: CameraState): boolean {\n        let updated = false;\n        if (newstate.motion_enabled !== undefined && newstate.motion_enabled !== this.motion_enabled) {\n            this.motion_enabled = newstate.motion_enabled;\n            updated = true;\n        }\n        if (newstate.detect_enabled !== undefined && newstate.detect_enabled !== this.detect_enabled) {\n            this.detect_enabled = newstate.detect_enabled;\n            updated = true;\n        }\n        if (newstate.task !== undefined && newstate.task !== this.task) {\n            this.task = newstate.task;\n            updated = true;\n        }\n        if (newstate.detected_objects !== undefined) {\n            // Only update if the array content is different\n            if (JSON.stringify(this.detected_objects) !== JSON.stringify(newstate.detected_objects)) {\n                this.detected_objects = newstate.detected_objects;\n                updated = true;\n            }\n        }\n        return updated;\n    }\n}\n", "import { z } from \"zod\";\n\nexport const configSchema = z.object({\n    \"mqtt_url\": z.string().default(\"mqtt://localhost\"),\n    \"mqtt_port\": z.number().default(1883),\n    \"mqtt_root\": z.string().default(\"frigate\"),\n    \"cameras\": z.array(z.object({\n        \"name\": z.string(),\n        \"rehome\": z.boolean().default(true),\n        \"rehome_after\": z.number().default(120),\n        \"patrols\": z.boolean().default(false),\n        \"patrol_every\": z.number().default(3600),\n        \"patrol_route\": z.array(z.string()).default(['1']),\n        \"want_motion\": z.boolean().default(true),\n        \"want_detect\": z.boolean().default(true),\n    }))\n});\n\nexport type Config = z.infer<typeof configSchema>;", "import { z } from \"zod\";\n\n// JSON object like this with every camera as a key in the top object:\n// {\"camera_name\": {\"motion\": false, \"objects\": [], \"config\": {\"detect\": true, \"snapshots\": false, \"record\": true, \"audio\": false, \"autotracking\": false}}, \"camera_name2\": {...}}\n// Note the \"motion\" and \"objects\" are what is CURRENTLY SENSED by the camera, not the config, unlike the \"config\" object\n\nexport const frigateStateSchema = z.record(z.string(), z.object({\n    motion: z.boolean(),\n    objects: z.array(z.string()),\n    config: z.object({\n        detect: z.boolean(),\n        snapshots: z.boolean(),\n        record: z.boolean(),\n        audio: z.boolean(),\n        autotracking: z.boolean()\n    })\n}));\n\nexport type FrigateState = z.infer<typeof frigateStateSchema>;\n"],
  "mappings": "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",
  "names": ["z", "cameraName", "camera"]
}
